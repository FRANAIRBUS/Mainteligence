rules_version = '2';

service firebase.storage {
  match /b/{bucket}/o {

    // --- FUNCIONES DE AYUDA ---
    function isSignedIn() {
      return request.auth != null;
    }


    function isValidOrgId(orgId) {
      return orgId is string && orgId.size() > 0;
    }

    function memberDoc(orgId, uid) {
      // Storage rules cannot use Firestore 'get' directly; must use firestore.get with (default) database.
      return firestore.get(/databases/(default)/documents/organizations/$(orgId)/members/$(uid));
    }

    function membershipDoc(orgId, uid) {
      return firestore.get(/databases/(default)/documents/memberships/$(uid + "_" + orgId));
    }

    function isActiveMembership(doc) {
      return doc != null
        && doc.data != null
        && (
          doc.data.active == true
          || doc.data.isActive == true
          || doc.data.status == "active"
        );
    }

    function isActiveMember(orgId, uid) {
      let member = memberDoc(orgId, uid);
      let membership = membershipDoc(orgId, uid);
      return isSignedIn()
        && isValidOrgId(orgId)
        && (isActiveMembership(member) || isActiveMembership(membership));
    }

    function ticketBelongsToOrg(orgId, id) {
      return isValidOrgId(orgId)
        && firestore.exists(/databases/(default)/documents/organizations/$(orgId)/tickets/$(id));
    }

    function uploadSession(orgId, id) {
      return firestore.get(/databases/(default)/documents/organizations/$(orgId)/uploadSessions/$(id));
    }

    function orgEntitlementLimits(orgId) {
      return firestore.get(/databases/(default)/documents/organizations/$(orgId)).data.entitlement.limits;
    }

    function orgEntitlementStatus(orgId) {
      return firestore.get(/databases/(default)/documents/organizations/$(orgId)).data.entitlement.status;
    }

    function orgPlanId(orgId) {
      return firestore.get(/databases/(default)/documents/organizations/$(orgId)).data.entitlement.planId;
    }

    function normalizedPlanId(planId) {
      return planId == "starter" || planId == "Starter" || planId == "STARTER"
        ? "starter"
        : planId == "pro" || planId == "Pro" || planId == "PRO"
          ? "pro"
          : planId == "enterprise" || planId == "Enterprise" || planId == "ENTERPRISE"
            ? "enterprise"
            : planId == "basic" || planId == "Basic" || planId == "BASIC"
              ? "basic"
              : "free";
    }

    function planCatalogDoc(planId) {
      return firestore.get(/databases/(default)/documents/planCatalog/$(planId));
    }

    function planCatalogLimits(planId) {
      let catalog = planCatalogDoc(normalizedPlanId(planId));
      return catalog != null && catalog.data != null ? catalog.data.limits : null;
    }

    function defaultAttachmentLimits(planId) {
      return planId == "starter" || planId == "Starter" || planId == "STARTER"
        ? 500
        : planId == "pro" || planId == "Pro" || planId == "PRO"
          ? 5000
          : planId == "enterprise" || planId == "Enterprise" || planId == "ENTERPRISE"
            ? 100000
            : 0;
    }

    function effectiveAttachmentLimits(orgId) {
      let planId = orgPlanId(orgId);
      let catalogLimits = planCatalogLimits(planId);
      let limits = orgEntitlementLimits(orgId);
      let defaults = defaultAttachmentLimits(planId);
      return catalogLimits != null
        && catalogLimits.attachmentsMonthlyMB is number
        && catalogLimits.maxAttachmentMB is number
        && catalogLimits.maxAttachmentsPerTicket is number
        && catalogLimits.attachmentsMonthlyMB > 0
        && catalogLimits.maxAttachmentMB > 0
        && catalogLimits.maxAttachmentsPerTicket > 0
        ? catalogLimits
        : limits != null
          && limits.attachmentsMonthlyMB is number
          && limits.maxAttachmentMB is number
          && limits.maxAttachmentsPerTicket is number
          && limits.attachmentsMonthlyMB > 0
          && limits.maxAttachmentMB > 0
          && limits.maxAttachmentsPerTicket > 0
          ? limits
          : defaults;
    }

    function attachmentsAllowed(orgId) {
      let status = orgEntitlementStatus(orgId);
      let limits = effectiveAttachmentLimits(orgId);
      return (status == "active" || status == "trialing")
        && limits != null
        && limits.attachmentsMonthlyMB is number
        && limits.maxAttachmentMB is number
        && limits.maxAttachmentMB > 0
        ? limits.maxAttachmentMB
        : defaultMaxAttachmentMB(planId);
    }

    function effectiveMaxAttachmentsPerTicket(orgId) {
      let limits = orgEntitlementLimits(orgId);
      let planId = orgPlanId(orgId);
      return limits != null
        && limits.maxAttachmentsPerTicket is number
        && limits.maxAttachmentsPerTicket > 0
        ? limits.maxAttachmentsPerTicket
        : defaultMaxAttachmentsPerTicket(planId);
    }

    function attachmentsAllowed(orgId) {
      return effectiveAttachmentsMonthlyMB(orgId) > 0
        && effectiveMaxAttachmentMB(orgId) > 0
        && effectiveMaxAttachmentsPerTicket(orgId) > 0;
    }

    function maxTicketAttachmentBytes(orgId) {
      return effectiveMaxAttachmentMB(orgId) * 1024 * 1024;
    }

    function hasActiveUploadSession(orgId, id) {
      let session = uploadSession(orgId, id);
      return session != null
        && session.data != null
        && session.data.status == 'active'
        && session.data.type == 'ticket'
        && session.data.uploaderUid == request.auth.uid
        && session.data.expiresAt is timestamp
        && session.data.expiresAt > request.time;
    }

    function hasRegisteredTicketUpload(orgId, id, fileName) {
      let session = uploadSession(orgId, id);
      return session != null
        && session.data != null
        && session.data.allowedFiles != null
        && session.data.allowedFiles[fileName] != null
        && session.data.allowedFiles[fileName].sizeBytes is number
        && session.data.allowedFiles[fileName].contentType is string
        && session.data.allowedFiles[fileName].sizeBytes == request.resource.size
        && session.data.allowedFiles[fileName].contentType == request.resource.contentType;
    }

    function isAllowedTicketContentType() {
      return request.resource.contentType.matches('image/.*')
        || request.resource.contentType == 'application/pdf'
        || request.resource.contentType.matches('text/.*')
        || request.resource.contentType == 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
        || request.resource.contentType == 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
        || request.resource.contentType == 'application/msword'
        || request.resource.contentType == 'application/vnd.ms-excel';
    }

    function taskBelongsToOrg(orgId, id) {
      return isValidOrgId(orgId)
        && firestore.exists(/databases/(default)/documents/organizations/$(orgId)/tasks/$(id));
    }

    function assetBelongsToOrg(orgId, id) {
      return isValidOrgId(orgId)
        && firestore.exists(/databases/(default)/documents/organizations/$(orgId)/assets/$(id));
    }

    function isValidImageUpload(maxBytes) {
      return request.resource != null
        && request.resource.size > 0
        && request.resource.size <= maxBytes
        && request.resource.contentType.matches('image/.*');
    }

    function isValidUpload(maxBytes) {
      return request.resource != null
        && request.resource.size > 0
        && request.resource.size <= maxBytes;
    }

    // --- REGLAS DE CARPETAS ---

    // 1. Logo de la empresa
    match /orgs/{orgId}/branding/logo.png {
      allow read: if true;
      allow write: if isSignedIn()
        && isValidOrgId(orgId)
        && isActiveMember(orgId, request.auth.uid)
        && isValidImageUpload(5 * 1024 * 1024);
    }

    // 2. Adjuntos de Incidencias (Tickets)
    // Hardened:
    // - Write requires either an existing ticket OR a short-lived upload session owned by the uploader.
    // - Read is allowed for members when the ticket exists, or for the uploader during the upload session (needed for getDownloadURL).
    // - Disallow nested directories to avoid arbitrary writes.
    match /orgs/{orgId}/tickets/{ticketId}/{fileName} {
      // If there is an active upload session owned by the caller, allow the upload/read
      // even if membership fields are temporarily inconsistent across collections.
      // Session creation itself is protected by Firestore rules.
      allow read: if isSignedIn()
        && isValidOrgId(orgId)
        && (
          (ticketBelongsToOrg(orgId, ticketId) && isActiveMember(orgId, request.auth.uid))
          || hasActiveUploadSession(orgId, ticketId)
        );
      // Writes are only allowed through a short-lived upload session created by Cloud Functions.
      // This prevents bypassing plan limits and enforces a server-side approval step.
      allow write: if isSignedIn()
        && isValidOrgId(orgId)
        && attachmentsAllowed(orgId)
        && hasActiveUploadSession(orgId, ticketId)
        && hasRegisteredTicketUpload(orgId, ticketId, fileName)
        && isValidUpload(maxTicketAttachmentBytes(orgId))
        && isAllowedTicketContentType();
    }

    // 3. Fotos de Tareas (Tasks)
    match /orgs/{orgId}/tasks/{taskId}/{allPaths=**} {
      allow read: if isSignedIn()
        && isValidOrgId(orgId)
        && isActiveMember(orgId, request.auth.uid)
        && taskBelongsToOrg(orgId, taskId);
      allow write: if isSignedIn()
        && isValidOrgId(orgId)
        && isActiveMember(orgId, request.auth.uid)
        && taskBelongsToOrg(orgId, taskId)
        && isValidImageUpload(10 * 1024 * 1024);
    }

    // 4. Activos (Assets)
    match /orgs/{orgId}/assets/{assetId}/{allPaths=**} {
      allow read: if isSignedIn()
        && isValidOrgId(orgId)
        && isActiveMember(orgId, request.auth.uid)
        && assetBelongsToOrg(orgId, assetId);
      allow write: if isSignedIn()
        && isValidOrgId(orgId)
        && isActiveMember(orgId, request.auth.uid)
        && assetBelongsToOrg(orgId, assetId)
        && isValidImageUpload(10 * 1024 * 1024);
    }

    // 5. Avatares de usuario
    match /users/{userId}/{fileName} {
      allow read: if isSignedIn() && fileName.matches('avatar\\..+');
      allow write: if isSignedIn()
        && request.auth.uid == userId
        && fileName.matches('avatar\\..+')
        && isValidImageUpload(5 * 1024 * 1024);
    }
  }
}
